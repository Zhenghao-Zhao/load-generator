import sched
import threading
import time

from .metric_struct import IncMetricStruct
from .metric_struct import RandMetricStruct


class Node:
    """the load generated by a node"""

    def __init__(self, metrics, schema, table, n_template):
        """takes in a dict of metrics, with metric value range as value"""

        self.metrics = metrics
        self.schema = schema
        self.table = table
        self.id = n_template['id']
        self.batch_size = 20
        self.period = 20
        self.__init_metrics()

    def __init_metrics(self):
        """initialize metrics"""

        mini_batch = {}

        # split data into batches of size 20 or less
        for metric_name, metric_pattern in self.metrics.items():

            # get the batch list for that metric
            batch_list = []
            for s in range(1, self.schema + 1):
                for t in range(1, self.table + 1):
                    k = '/metrics/type=IndexTable/keyspace={}/scope={}/name={}/mean'.format(s, t, metric_name)
                    # From Python 3.6 onwards, the standard dict type maintains insertion order by default.
                    mini_batch[k] = 0
                    # if the batch has 20 items or at the end of iteration,
                    # append the batch to list of that metric and create a new empty batch
                    if len(mini_batch) == self.batch_size or (s == self.schema and t == self.table):
                        batch_list.append(mini_batch)
                        mini_batch = {}

            # parse metric patterns
            l = metric_pattern.split()
            if l[0] == '(>':
                self.metrics[metric_name] = IncMetricStruct(float(l[2][1:]), float(l[4][:-2]), batch_list)
            else:
                self.metrics[metric_name] = RandMetricStruct(float(l[0][1:]), float(l[-1][:-1]), batch_list)

    def get_next_batch(self):
        """get the next batch (a dict) off each metric struct and combine them into single dict"""

        metrics = {}
        for struct in self.metrics.values():
            metrics = {**metrics, **struct.get_next_batch()}

        return metrics


class Cluster:
    """a collection of loads generated by a number of nodes"""

    def __init__(self, specs, client):
        self.id = specs['id']
        self.nodes = []
        self.client = client
        self.period = 20
        self.__init_load(specs)

    def __init_load(self, specs):
        """initialize node load according to given specs"""

        node_templates = specs['nodes']
        lst = []
        for n in node_templates:
            node_num = n['count']
            for i in range(node_num):
                node = Node({**specs['metrics'], **n['additional_metrics']}, specs['schema'],
                            specs['table'], n)
                # amoritized 0(1)
                lst.append(node)

        self.nodes = lst

    def dispatch_load(self):
        """dispatch load from nodes in this cluster"""

        # Create multiple scheduler threads that add a load thread every 20s
        for node in self.nodes:
            threading.Thread(target=self.__start_load, args=(node,)).start()

    def __start_load(self, node):
        """run a python scheduler periodically. The scheduler starts a new thread that generates and sends load"""

        # Fire a thread immediately for the first time
        self.__send_load(node.get_next_batch())

        s = sched.scheduler(time.time, time.sleep)
        while True:
            s.enter(self.period, 1, self.__send_load, argument=(node.get_next_batch(),))
            s.run()

    def __send_load(self, metrics):
        """start a load thread"""

        # send load
        try:
            threading.Thread(target=self.client.send, args=(metrics,)).start()
        except:
            print("Error: unable to start thread")
